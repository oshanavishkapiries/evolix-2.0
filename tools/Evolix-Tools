{"cells":[{"cell_type":"code","execution_count":null,"metadata":{"cellView":"form","id":"st-6sRptjlzK"},"outputs":[],"source":["# @title SUB EXTRACTOR\n","import os\n","import re\n","import subprocess\n","\n","folder_path = \"/content/drive/Shareddrives/Drive.02/Chernobyl.2019\"  # @param {\"type\":\"string\",\"placeholder\":\"/content/folder_name\"}\n","output_base_path = \"/content/drive/Shareddrives/Drive.02/sub\" # @param {\"type\":\"string\",\"placeholder\":\"/content/folder_name\"}\n","\n","# Supported video file extensions\n","VIDEO_EXTENSIONS = ('.mkv', '.mp4', '.avi', '.mov', '.wmv')\n","\n","def get_video_file_paths(folder_path):\n","    video_files = []\n","    for root, _, files in os.walk(folder_path):\n","        for file in files:\n","            if file.lower().endswith(VIDEO_EXTENSIONS):\n","                video_files.append(os.path.join(root, file))\n","    return video_files\n","\n","def detect_season(file_name):\n","    # Regex to detect season (e.g., S01, s01, Season 1)\n","    season_match = re.search(r'[sS](\\d{1,2})[eE]?\\d{0,2}|Season\\s*(\\d{1,2})', file_name)\n","    if season_match:\n","        # Extract season number (from S01 or Season 1)\n","        season_num = season_match.group(1) or season_match.group(2)\n","        return f\"s{int(season_num):02d}\"  # Format as s01, s02, etc.\n","    return None\n","\n","def extract_subtitles(video_path, output_base_path):\n","    # Create output folder if it doesn't exist\n","    if not os.path.exists(output_base_path):\n","        os.makedirs(output_base_path)\n","\n","    # Determine if it's a season or movie\n","    file_name = os.path.basename(video_path)\n","    season = detect_season(file_name)\n","\n","    if season:\n","        output_folder = os.path.join(output_base_path, season)\n","    else:\n","        output_folder = os.path.join(output_base_path, \"movies\")\n","\n","    if not os.path.exists(output_folder):\n","        os.makedirs(output_folder)\n","\n","    # Use ffprobe to detect embedded subtitles\n","    probe_cmd = [\n","        'ffprobe', '-i', video_path,\n","        '-print_format', 'json',\n","        '-show_streams',\n","        '-loglevel', 'error'\n","    ]\n","    probe_result = subprocess.run(probe_cmd, capture_output=True, text=True)\n","    probe_data = eval(probe_result.stdout.replace('true', 'True').replace('false', 'False'))  # Simple JSON parse\n","\n","    subtitle_count = 0\n","    for stream in probe_data.get('streams', []):\n","        if stream.get('codec_type') == 'subtitle':\n","            subtitle_count += 1\n","            subtitle_ext = '.srt'  # Default, can be adjusted based on codec\n","            if stream.get('codec_name') == 'webvtt':\n","                subtitle_ext = '.vtt'\n","            elif stream.get('codec_name') in ['ass', 'ssa']:\n","                subtitle_ext = '.ass'\n","\n","            output_file = os.path.join(output_folder, f\"{os.path.splitext(file_name)[0]}_sub{subtitle_count}{subtitle_ext}\")\n","\n","            # Extract subtitle with ffmpeg\n","            ffmpeg_cmd = [\n","                'ffmpeg', '-i', video_path,\n","                '-map', f'0:{stream[\"index\"]}',\n","                '-c:s', 'copy',\n","                output_file,\n","                '-y'  # Overwrite if exists\n","            ]\n","            subprocess.run(ffmpeg_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n","            print(f\"Extracted subtitle: {output_file}\")\n","\n","def process_videos_and_extract_subtitles(folder_path):\n","    video_files = get_video_file_paths(folder_path)\n","    if video_files:\n","        for video_path in video_files:\n","            print(f\"Processing: {video_path}\")\n","            extract_subtitles(video_path, output_base_path)\n","        print(f\"\\nTotal number of video files processed: {len(video_files)}\")\n","    else:\n","        print(\"No video files found in the specified folder.\")\n","\n","# Run the script\n","process_videos_and_extract_subtitles(folder_path)"]},{"cell_type":"code","execution_count":null,"metadata":{"cellView":"form","id":"m5-1vKgCJKDs"},"outputs":[],"source":["# @title MIXDROP UPLOADER\n","\n","import os\n","import requests\n","import csv\n","from pathlib import Path\n","\n","folder_path = \"/content/drive/Shareddrives/Drive.02/Chernobyl.2019\"  # @param {\"type\":\"string\",\"placeholder\":\"/content/folder_name\"}\n","mixdrop_email = \"oshanavishka6@gmail.com\"  # @param {\"type\":\"string\",\"placeholder\":\"email\"}\n","mixdrop_api_key = \"o6chuAOZra0pqxZNs6CW\"  # @param {\"type\":\"string\",\"placeholder\":\"api-key\"}\n","mixdrop_root_folder = \"Chernobyl.2019\"  # @param {\"type\":\"string\",\"placeholder\":\"MyMixdropFolder\"}\n","csv_file_path = \"/content/drive/MyDrive/links/Chernobyl.2019\"  # @param {\"type\":\"string\",\"placeholder\":\"/content/upload_links.csv\"}\n","\n","# Mixdrop API endpoints\n","UPLOAD_URL = \"https://ul.mixdrop.ag/api\"\n","FOLDER_CREATE_URL = \"https://api.mixdrop.ag/foldercreate\"\n","\n","def get_file_paths(folder_path):\n","    \"\"\"Recursively get all file paths in the folder.\"\"\"\n","    file_paths = []\n","    for root, _, files in os.walk(folder_path):\n","        for file in files:\n","            file_paths.append(os.path.join(root, file))\n","    return file_paths\n","\n","def create_mixdrop_folder(folder_name, parent_id=None, email=mixdrop_email, api_key=mixdrop_api_key):\n","    \"\"\"Create a folder on Mixdrop and return its ID.\"\"\"\n","    params = {\n","        \"email\": email,\n","        \"key\": api_key,\n","        \"title\": folder_name\n","    }\n","    if parent_id:\n","        params[\"parent\"] = parent_id\n","\n","    response = requests.get(FOLDER_CREATE_URL, params=params)\n","    if response.status_code == 200:\n","        data = response.json()\n","        if data.get(\"success\"):\n","            print(f\"Created folder '{folder_name}' with ID: {data['result']['id']}\")\n","            return data[\"result\"][\"id\"]\n","        else:\n","            print(f\"Failed to create folder '{folder_name}': {data}\")\n","            return None\n","    else:\n","        print(f\"Error creating folder '{folder_name}': {response.status_code} - {response.text}\")\n","        return None\n","\n","def upload_to_mixdrop(file_path, folder_id=None, email=mixdrop_email, api_key=mixdrop_api_key):\n","    \"\"\"Upload a file to Mixdrop with optional folder ID and return URL.\"\"\"\n","    params = {\n","        \"email\": email,\n","        \"key\": api_key\n","    }\n","    if folder_id:\n","        params[\"folder\"] = folder_id\n","\n","    try:\n","        with open(file_path, \"rb\") as f:\n","            files = {\"file\": (os.path.basename(file_path), f)}\n","            response = requests.post(UPLOAD_URL, data=params, files=files)\n","\n","            if response.status_code == 200:\n","                data = response.json()\n","                if data.get(\"success\"):\n","                    url = data[\"result\"][\"url\"]\n","                    print(f\"Successfully uploaded {file_path}: {url}\")\n","                    return url  # Return the 'url' instead of 'embedurl'\n","                else:\n","                    print(f\"Upload failed for {file_path}: {data}\")\n","            else:\n","                print(f\"Error uploading {file_path}: {response.status_code} - {response.text}\")\n","    except Exception as e:\n","        print(f\"Exception during upload of {file_path}: {str(e)}\")\n","    return None\n","\n","def upload_folder_to_mixdrop(folder_path, root_folder_name, csv_path, email=mixdrop_email, api_key=mixdrop_api_key):\n","    \"\"\"Upload files to Mixdrop under a root folder and save links to CSV.\"\"\"\n","    if not os.path.exists(folder_path):\n","        print(f\"Folder {folder_path} does not exist.\")\n","        return\n","\n","    file_paths = get_file_paths(folder_path)\n","    if not file_paths:\n","        print(\"No files found in the specified folder.\")\n","        return\n","\n","    # Validate CSV path\n","    csv_dir = os.path.dirname(csv_path) or \".\"\n","    if not os.path.exists(csv_dir):\n","        try:\n","            os.makedirs(csv_dir, exist_ok=True)\n","            print(f\"Created directory for CSV: {csv_dir}\")\n","        except Exception as e:\n","            print(f\"Failed to create CSV directory {csv_dir}: {str(e)}\")\n","            return\n","\n","    # Check if CSV path is writable\n","    try:\n","        with open(csv_path, \"w\") as test_file:\n","            test_file.write(\"test\")\n","        os.remove(csv_path)\n","    except Exception as e:\n","        print(f\"CSV path {csv_path} is not writable: {str(e)}\")\n","        return\n","\n","    # Create the root folder on Mixdrop\n","    root_folder_id = create_mixdrop_folder(root_folder_name)\n","    if not root_folder_id:\n","        print(f\"Aborting upload due to failure in creating root folder '{root_folder_name}'.\")\n","        return\n","\n","    # Cache for folder IDs\n","    folder_cache = {\".\": root_folder_id}\n","\n","    # List to store file info for CSV\n","    csv_data = []\n","\n","    for file_path in file_paths:\n","        relative_path = os.path.relpath(file_path, folder_path)\n","        folder_structure = os.path.dirname(relative_path)\n","\n","        # Handle folder structure under the root folder\n","        if folder_structure and folder_structure != \".\":\n","            current_parent = root_folder_id\n","            folder_parts = folder_structure.split(os.sep)\n","            for part in folder_parts:\n","                folder_key = os.path.join(*folder_parts[:folder_parts.index(part) + 1])\n","                if folder_key not in folder_cache:\n","                    folder_id = create_mixdrop_folder(part, parent_id=current_parent)\n","                    if folder_id:\n","                        folder_cache[folder_key] = folder_id\n","                        current_parent = folder_id\n","                    else:\n","                        current_parent = None\n","                        break\n","                else:\n","                    current_parent = folder_cache[folder_key]\n","            folder_id = current_parent\n","        else:\n","            folder_id = root_folder_id\n","\n","        # Upload the file and get URL\n","        url = upload_to_mixdrop(file_path, folder_id)\n","        if url:\n","            csv_data.append({\n","                \"file_name\": os.path.basename(file_path),\n","                \"link\": url\n","            })\n","\n","    # Write to CSV with error handling\n","    if csv_data:\n","        try:\n","            with open(csv_path, \"w\", newline=\"\", encoding=\"utf-8\") as csvfile:\n","                fieldnames = [\"file_name\", \"link\"]\n","                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n","                writer.writeheader()\n","                writer.writerows(csv_data)\n","            print(f\"CSV file successfully saved at {csv_path} with {len(csv_data)} entries\")\n","        except Exception as e:\n","            print(f\"Failed to write CSV at {csv_path}: {str(e)}\")\n","    else:\n","        print(\"No data to write to CSV - no successful uploads.\")\n","\n","    print(f\"\\nTotal number of files processed: {len(file_paths)}\")\n","\n","# Run the uploader\n","upload_folder_to_mixdrop(folder_path, mixdrop_root_folder, csv_file_path, mixdrop_email, mixdrop_api_key)"]},{"cell_type":"code","source":["# @title SRT TO VTT\n","\n","# For local use\n","import os\n","\n","def srt_to_vtt(srt_content):\n","    vtt_content = \"WEBVTT\\n\\n\"\n","    blocks = srt_content.strip().split('\\n\\n')\n","    for block in blocks:\n","        lines = block.strip().split('\\n')\n","        if len(lines) >= 2:\n","            timing = lines[1].replace(',', '.')\n","            text = '\\n'.join(lines[2:])\n","            vtt_content += f\"{timing}\\n{text}\\n\\n\"\n","    return vtt_content\n","\n","def convert_srt_files_in_folder(input_folder, output_folder):\n","    if not os.path.exists(output_folder):\n","        os.makedirs(output_folder)\n","\n","    processed_count = 0\n","    for filename in os.listdir(input_folder):\n","        if filename.lower().endswith('.srt'):\n","            input_path = os.path.join(input_folder, filename)\n","            output_filename = filename.replace('.srt', '.vtt')\n","            output_path = os.path.join(output_folder, output_filename)\n","\n","            try:\n","                with open(input_path, 'r', encoding='utf-8') as f:\n","                    srt_content = f.read()\n","                vtt_content = srt_to_vtt(srt_content)\n","                with open(output_path, 'w', encoding='utf-8') as f:\n","                    f.write(vtt_content)\n","                processed_count += 1\n","                print(f\"Converted: {filename} -> {output_filename}\")\n","            except Exception as e:\n","                print(f\"Error converting {filename}: {str(e)}\")\n","\n","    return processed_count\n","\n","def process_local_folder(input_folder_path):\n","    if not os.path.exists(input_folder_path):\n","        print(f\"Error: Folder '{input_folder_path}' does not exist\")\n","        return\n","\n","    output_folder = os.path.join(input_folder_path, 'vtt_output')\n","    count = convert_srt_files_in_folder(input_folder_path, output_folder)\n","    print(f\"Processed {count} SRT files. Output saved to {output_folder}\")\n","\n","folder_path = \"/content/drive/Shareddrives/Drive.02/sub/movies\"  # @param {\"type\":\"string\",\"placeholder\":\"/content/folder_name\"}\n","process_local_folder(folder_path)"],"metadata":{"cellView":"form","id":"YZuhkU5ulQDa"},"execution_count":null,"outputs":[]}],"metadata":{"colab":{"provenance":[],"mount_file_id":"1OKGY9mCrqP9N39MtqXG1Pm43JHpUSfLK","authorship_tag":"ABX9TyNYf2CzsHS8L2lgsOlbUqT0"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}